/*
 * GNU GENERAL PUBLIC LICENSE
 *                        Version 2, June 1991
 *
 *  Copyright (C) 1989, 1991 Free Software Foundation, Inc., <http://fsf.org/>
 *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 *  Everyone is permitted to copy and distribute verbatim copies
 *  of this license document, but changing it is not allowed.
 *
 *                             Preamble
 *
 *   The licenses for most software are designed to take away your
 * freedom to share and change it.  By contrast, the GNU General Public
 * License is intended to guarantee your freedom to share and change free
 * software--to make sure the software is free for all its users.  This
 * General Public License applies to most of the Free Software
 * Foundation's software and to any other program whose authors commit to
 * using it.  (Some other Free Software Foundation software is covered by
 * the GNU Lesser General Public License instead.)  You can apply it to
 * your programs, too.
 *
 *   When we speak of free software, we are referring to freedom, not
 * price.  Our General Public Licenses are designed to make sure that you
 * have the freedom to distribute copies of free software (and charge for
 * this service if you wish), that you receive source code or can get it
 * if you want it, that you can change the software or use pieces of it
 * in new free programs; and that you know you can do these things.
 *
 *   To protect your rights, we need to make restrictions that forbid
 * anyone to deny you these rights or to ask you to surrender the rights.
 * These restrictions translate to certain responsibilities for you if you
 * distribute copies of the software, or if you modify it.
 *
 *   For example, if you distribute copies of such a program, whether
 * gratis or for a fee, you must give the recipients all the rights that
 * you have.  You must make sure that they, too, receive or can get the
 * source code.  And you must show them these terms so they know their
 * rights.
 *
 *   We protect your rights with two steps: (1) copyright the software, and
 * (2) offer you this license which gives you legal permission to copy,
 * distribute and/or modify the software.
 *
 *   Also, for each author's protection and ours, we want to make certain
 * that everyone understands that there is no warranty for this free
 * software.  If the software is modified by someone else and passed on, we
 * want its recipients to know that what they have is not the original, so
 * that any problems introduced by others will not reflect on the original
 * authors' reputations.
 *
 *   Finally, any free program is threatened constantly by software
 * patents.  We wish to avoid the danger that redistributors of a free
 * program will individually obtain patent licenses, in effect making the
 * program proprietary.  To prevent this, we have made it clear that any
 * patent must be licensed for everyone's free use or not licensed at all.
 *
 *   The precise terms and conditions for copying, distribution and
 * modification follow.
 *
 *                     GNU GENERAL PUBLIC LICENSE
 *    TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
 *
 *   0. This License applies to any program or other work which contains
 * a notice placed by the copyright holder saying it may be distributed
 * under the terms of this General Public License.  The "Program", below,
 * refers to any such program or work, and a "work based on the Program"
 * means either the Program or any derivative work under copyright law:
 * that is to say, a work containing the Program or a portion of it,
 * either verbatim or with modifications and/or translated into another
 * language.  (Hereinafter, translation is included without limitation in
 * the term "modification".)  Each licensee is addressed as "you".
 *
 * Activities other than copying, distribution and modification are not
 * covered by this License; they are outside its scope.  The act of
 * running the Program is not restricted, and the output from the Program
 * is covered only if its contents constitute a work based on the
 * Program (independent of having been made by running the Program).
 * Whether that is true depends on what the Program does.
 *
 *   1. You may copy and distribute verbatim copies of the Program's
 * source code as you receive it, in any medium, provided that you
 * conspicuously and appropriately publish on each copy an appropriate
 * copyright notice and disclaimer of warranty; keep intact all the
 * notices that refer to this License and to the absence of any warranty;
 * and give any other recipients of the Program a copy of this License
 * along with the Program.
 *
 * You may charge a fee for the physical act of transferring a copy, and
 * you may at your option offer warranty protection in exchange for a fee.
 *
 *   2. You may modify your copy or copies of the Program or any portion
 * of it, thus forming a work based on the Program, and copy and
 * distribute such modifications or work under the terms of Section 1
 * above, provided that you also meet all of these conditions:
 *
 *     a) You must cause the modified files to carry prominent notices
 *     stating that you changed the files and the date of any change.
 *
 *     b) You must cause any work that you distribute or publish, that in
 *     whole or in part contains or is derived from the Program or any
 *     part thereof, to be licensed as a whole at no charge to all third
 *     parties under the terms of this License.
 *
 *     c) If the modified program normally reads commands interactively
 *     when run, you must cause it, when started running for such
 *     interactive use in the most ordinary way, to print or display an
 *     announcement including an appropriate copyright notice and a
 *     notice that there is no warranty (or else, saying that you provide
 *     a warranty) and that users may redistribute the program under
 *     these conditions, and telling the user how to view a copy of this
 *     License.  (Exception: if the Program itself is interactive but
 *     does not normally print such an announcement, your work based on
 *     the Program is not required to print an announcement.)
 *
 * These requirements apply to the modified work as a whole.  If
 * identifiable sections of that work are not derived from the Program,
 * and can be reasonably considered independent and separate works in
 * themselves, then this License, and its terms, do not apply to those
 * sections when you distribute them as separate works.  But when you
 * distribute the same sections as part of a whole which is a work based
 * on the Program, the distribution of the whole must be on the terms of
 * this License, whose permissions for other licensees extend to the
 * entire whole, and thus to each and every part regardless of who wrote it.
 *
 * Thus, it is not the intent of this section to claim rights or contest
 * your rights to work written entirely by you; rather, the intent is to
 * exercise the right to control the distribution of derivative or
 * collective works based on the Program.
 *
 * In addition, mere aggregation of another work not based on the Program
 * with the Program (or with a work based on the Program) on a volume of
 * a storage or distribution medium does not bring the other work under
 * the scope of this License.
 *
 *   3. You may copy and distribute the Program (or a work based on it,
 * under Section 2) in object code or executable form under the terms of
 * Sections 1 and 2 above provided that you also do one of the following:
 *
 *     a) Accompany it with the complete corresponding machine-readable
 *     source code, which must be distributed under the terms of Sections
 *     1 and 2 above on a medium customarily used for software interchange; or,
 *
 *     b) Accompany it with a written offer, valid for at least three
 *     years, to give any third party, for a charge no more than your
 *     cost of physically performing source distribution, a complete
 *     machine-readable copy of the corresponding source code, to be
 *     distributed under the terms of Sections 1 and 2 above on a medium
 *     customarily used for software interchange; or,
 *
 *     c) Accompany it with the information you received as to the offer
 *     to distribute corresponding source code.  (This alternative is
 *     allowed only for noncommercial distribution and only if you
 *     received the program in object code or executable form with such
 *     an offer, in accord with Subsection b above.)
 *
 * The source code for a work means the preferred form of the work for
 * making modifications to it.  For an executable work, complete source
 * code means all the source code for all modules it contains, plus any
 * associated interface definition files, plus the scripts used to
 * control compilation and installation of the executable.  However, as a
 * special exception, the source code distributed need not include
 * anything that is normally distributed (in either source or binary
 * form) with the major components (compiler, kernel, and so on) of the
 * operating system on which the executable runs, unless that component
 * itself accompanies the executable.
 *
 * If distribution of executable or object code is made by offering
 * access to copy from a designated place, then offering equivalent
 * access to copy the source code from the same place counts as
 * distribution of the source code, even though third parties are not
 * compelled to copy the source along with the object code.
 *
 *   4. You may not copy, modify, sublicense, or distribute the Program
 * except as expressly provided under this License.  Any attempt
 * otherwise to copy, modify, sublicense or distribute the Program is
 * void, and will automatically terminate your rights under this License.
 * However, parties who have received copies, or rights, from you under
 * this License will not have their licenses terminated so long as such
 * parties remain in full compliance.
 *
 *   5. You are not required to accept this License, since you have not
 * signed it.  However, nothing else grants you permission to modify or
 * distribute the Program or its derivative works.  These actions are
 * prohibited by law if you do not accept this License.  Therefore, by
 * modifying or distributing the Program (or any work based on the
 * Program), you indicate your acceptance of this License to do so, and
 * all its terms and conditions for copying, distributing or modifying
 * the Program or works based on it.
 *
 *   6. Each time you redistribute the Program (or any work based on the
 * Program), the recipient automatically receives a license from the
 * original licensor to copy, distribute or modify the Program subject to
 * these terms and conditions.  You may not impose any further
 * restrictions on the recipients' exercise of the rights granted herein.
 * You are not responsible for enforcing compliance by third parties to
 * this License.
 *
 *   7. If, as a consequence of a court judgment or allegation of patent
 * infringement or for any other reason (not limited to patent issues),
 * conditions are imposed on you (whether by court order, agreement or
 * otherwise) that contradict the conditions of this License, they do not
 * excuse you from the conditions of this License.  If you cannot
 * distribute so as to satisfy simultaneously your obligations under this
 * License and any other pertinent obligations, then as a consequence you
 * may not distribute the Program at all.  For example, if a patent
 * license would not permit royalty-free redistribution of the Program by
 * all those who receive copies directly or indirectly through you, then
 * the only way you could satisfy both it and this License would be to
 * refrain entirely from distribution of the Program.
 *
 * If any portion of this section is held invalid or unenforceable under
 * any particular circumstance, the balance of the section is intended to
 * apply and the section as a whole is intended to apply in other
 * circumstances.
 *
 * It is not the purpose of this section to induce you to infringe any
 * patents or other property right claims or to contest validity of any
 * such claims; this section has the sole purpose of protecting the
 * integrity of the free software distribution system, which is
 * implemented by public license practices.  Many people have made
 * generous contributions to the wide range of software distributed
 * through that system in reliance on consistent application of that
 * system; it is up to the author/donor to decide if he or she is willing
 * to distribute software through any other system and a licensee cannot
 * impose that choice.
 *
 * This section is intended to make thoroughly clear what is believed to
 * be a consequence of the rest of this License.
 *
 *   8. If the distribution and/or use of the Program is restricted in
 * certain countries either by patents or by copyrighted interfaces, the
 * original copyright holder who places the Program under this License
 * may add an explicit geographical distribution limitation excluding
 * those countries, so that distribution is permitted only in or among
 * countries not thus excluded.  In such case, this License incorporates
 * the limitation as if written in the body of this License.
 *
 *   9. The Free Software Foundation may publish revised and/or new versions
 * of the General Public License from time to time.  Such new versions will
 * be similar in spirit to the present version, but may differ in detail to
 * address new problems or concerns.
 *
 * Each version is given a distinguishing version number.  If the Program
 * specifies a version number of this License which applies to it and "any
 * later version", you have the option of following the terms and conditions
 * either of that version or of any later version published by the Free
 * Software Foundation.  If the Program does not specify a version number of
 * this License, you may choose any version ever published by the Free Software
 * Foundation.
 *
 *   10. If you wish to incorporate parts of the Program into other free
 * programs whose distribution conditions are different, write to the author
 * to ask for permission.  For software which is copyrighted by the Free
 * Software Foundation, write to the Free Software Foundation; we sometimes
 * make exceptions for this.  Our decision will be guided by the two goals
 * of preserving the free status of all derivatives of our free software and
 * of promoting the sharing and reuse of software generally.
 *
 *                             NO WARRANTY
 *
 *   11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
 * FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
 * OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
 * PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
 * OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
 * TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
 * PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
 * REPAIR OR CORRECTION.
 *
 *   12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
 * WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
 * REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
 * INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
 * OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
 * TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
 * YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
 * PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGES.
 *
 *                      END OF TERMS AND CONDITIONS
 *
 *             How to Apply These Terms to Your New Programs
 *
 *   If you develop a new program, and you want it to be of the greatest
 * possible use to the public, the best way to achieve this is to make it
 * free software which everyone can redistribute and change under these terms.
 *
 *   To do so, attach the following notices to the program.  It is safest
 * to attach them to the start of each source file to most effectively
 * convey the exclusion of warranty; and each file should have at least
 * the "copyright" line and a pointer to where the full notice is found.
 *
 *     {description}
 *     Copyright (C) {year}  {fullname}
 *
 *     This program is free software; you can redistribute it and/or modify
 *     it under the terms of the GNU General Public License as published by
 *     the Free Software Foundation; either version 2 of the License, or
 *     (at your option) any later version.
 *
 *     This program is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *     GNU General Public License for more details.
 *
 *     You should have received a copy of the GNU General Public License along
 *     with this program; if not, write to the Free Software Foundation, Inc.,
 *     51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Also add information on how to contact you by electronic and paper mail.
 *
 * If the program is interactive, make it output a short notice like this
 * when it starts in an interactive mode:
 *
 *     Gnomovision version 69, Copyright (C) year name of author
 *     Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
 *     This is free software, and you are welcome to redistribute it
 *     under certain conditions; type `show c' for details.
 *
 * The hypothetical commands `show w' and `show c' should show the appropriate
 * parts of the General Public License.  Of course, the commands you use may
 * be called something other than `show w' and `show c'; they could even be
 * mouse-clicks or menu items--whatever suits your program.
 *
 * You should also get your employer (if you work as a programmer) or your
 * school, if any, to sign a "copyright disclaimer" for the program, if
 * necessary.  Here is a sample; alter the names:
 *
 *   Yoyodyne, Inc., hereby disclaims all copyright interest in the program
 *   `Gnomovision' (which makes passes at compilers) written by James Hacker.
 *
 *   {signature of Ty Coon}, 1 April 1989
 *   Ty Coon, President of Vice
 *
 * This General Public License does not permit incorporating your program into
 * proprietary programs.  If your program is a subroutine library, you may
 * consider it more useful to permit linking proprietary applications with the
 * library.  If this is what you want to do, use the GNU Lesser General
 * Public License instead of this License.
 */

package controllers

import java.net.URI
import java.nio.charset.Charset
import java.nio.file._
import javax.inject.Inject

import com.fasterxml.jackson.databind.ObjectMapper
import com.sun.nio.zipfs.ZipFileSystemProvider
import controllers.traits.{ TController}
import logic.helpers.{DeleteDirectoryHelper, DirectoryCopyHelper, ZIPFileDirectoryCopyHelper, ZIPFileExtractHelper}
import models.Transactions
import models.export.JsonContainer
import models.fhs.pages.JavaList
import models.fhs.pages.exporter.MExporter._
import models.fhs.pages.generator.MGenerator._
import models.persistence.Schedule
import models.persistence.criteria.TimeSlotCriteria
import models.persistence.enumerations.ELectureKind
import models.persistence.lecture.Lecture
import models.persistence.location.{HouseEntity, RoomAttributesEntity}
import models.persistence.participants.Course
import models.persistence.scheduletree.{TimeSlot, Weekday}
import models.persistence.subject.AbstractSubject
import models.persistence.template.WeekdayTemplate
import org.hibernate.FetchMode
import org.hibernate.criterion.{CriteriaSpecification, Restrictions}
import play.api.Play
import play.api.Play.current
import play.api.i18n.MessagesApi
import play.api.libs.iteratee.{Enumerator, Enumeratee}
import play.api.libs.json._
import play.api.mvc._
import views.html.exporter._
import informations.BuildInfo

import scala.collection.JavaConversions._


/**
 * @author fabian 
 *         on 24.03.14.
 */

class  CExporter @Inject() (val messagesApi: MessagesApi) extends TController {



  def page = Action {
    implicit request =>

      import models.fhs.pages.exporter.MExporter._
      Ok(exporter("Expotieren/Importieren", findSemesters))
  }

  def export = Action {

    implicit request =>

      val jsonExport = Transactions.hibernateAction {
        implicit session =>
          val houses = session.createCriteria(classOf[HouseEntity]).setFetchMode("rooms", FetchMode.JOIN).setResultTransformer(CriteriaSpecification.DISTINCT_ROOT_ENTITY).list().asInstanceOf[JavaList[HouseEntity]]
          val subjectCriterion = session.createCriteria(classOf[AbstractSubject]).setResultTransformer(CriteriaSpecification.DISTINCT_ROOT_ENTITY)

          subjectCriterion.createCriteria("courses").setFetchMode("groups", FetchMode.JOIN)

          //val subjects = subjectCriterion.list().asInstanceOf[JavaList[AbstractSubject]]

          val weekdayTemplates = session.createCriteria(classOf[WeekdayTemplate]).setResultTransformer(CriteriaSpecification.DISTINCT_ROOT_ENTITY).list().asInstanceOf[JavaList[WeekdayTemplate]]

          val jsonContainer = new JsonContainer
          jsonContainer.setHouses(houses)
          //jsonContainer.setSubjects(subjects)
          jsonContainer.setSubjects(List[AbstractSubject]())
          jsonContainer.setWeekdayTemplates(weekdayTemplates)
          jsonContainer
      }

      val mapper = new ObjectMapper

      Ok(Json.prettyPrint(Json.parse(mapper.writeValueAsString(jsonExport)))).withHeaders(("Content-disposition", "attachment; filename=data.json"))

  }


  /**
   * create data for spirit news system
   * it creates a ZIP - file, which includes all necessary json files for spirit data and an install script
   *
   * @param id - the id of the Schedule
   */
  def createSpiritSchedule(id: Long) = Action {
  import scala.concurrent.ExecutionContext.Implicits.global
    def timeSlotToString(timeSlot: TimeSlot) = {
      val sb = new StringBuilder

      sb append timeSlot.getStartHour.formatted("%02d")
      sb append "."
      sb append timeSlot.getStartMinute.formatted("%02d")
      sb append "-"
      sb append timeSlot.getStopHour.formatted("%02d")
      sb append "."
      sb append timeSlot.getStopMinute.formatted("%02d")
      sb.toString
    }


    val semester = findSemester(id)
    val schedule = findScheduleForSemester(semester)
    val fileName = "schedule" + semester.getName.replaceAll("/", "") + System.currentTimeMillis()
    val path = Files.createTempDirectory(fileName)

    val env = Map("create" -> "true")
    val zipUri = URI.create(("jar:file:" + path.getParent.toString + "/" + fileName + ".zip").replaceAll(" ", ""))
    val zipFs = FileSystems.newFileSystem(zipUri, env)



    val weekDays = Map((1, "Montag"), (2, "Dienstag"), (3, "Mittwoch"), (4, "Donnerstag"), (5, "Freitag"), (6, "Samstag"), (0, "Sonntag"))

    val importScriptFile = Files.createFile(Paths.get(path.toString, "import.sh"))

    var firstRun = true

    Transactions.hibernateAction {
      implicit s =>
        val courses = s.createCriteria(classOf[Course]).list().asInstanceOf[JavaList[Course]]
        var importCommands = courses.par.map {
          course =>

            val tmpFile = Files.createFile(Paths.get(path.toString, course.getName.toLowerCase + ".json"))
            val filteredSchedule = schedule.filter(course)

            val allTimeSlots = filteredSchedule.getRoot.getChildren.flatMap {
              case wd: Weekday =>
                wd.getChildren.asInstanceOf[JavaList[TimeSlot]]
            }

            val allLectures = filteredSchedule.getRoot.getChildren.flatMap {
              case wd: Weekday =>
                wd.getChildren.flatMap {
                  case ts: TimeSlot => ts.getLectures
                }
            }.toSet

            val plan = allLectures.flatMap {
              case lecture: Lecture =>

                val timeSlots = allTimeSlots.filter(_.getLectures.contains(lecture))
                timeSlots.map { timeSlot =>
                  val day = weekDays(timeSlot.getParent.asInstanceOf[Weekday].getSortIndex)
                  val eventType = lecture.getKind match {
                    case ELectureKind.LECTURE => "Vorlesung"
                    case ELectureKind.EXERCISE => "Uebung"
                  }

                  val group = lecture.getKind match {
                    case ELectureKind.LECTURE => ""
                    case ELectureKind.EXERCISE => val g = lecture.getLectureParticipants.find(_.getCourseName.equals(course.getShortName)).get
                      if (g.isIgnoreGroupIndex == true) {
                        ""
                      } else {
                        g.getGroupIndex.toString
                      }

                  }
                  /** Spirit hour is not hour of day, it is index of the timeslot per day */
                  val alternativeHour = timeSlot.getParent.getChildren.toList.asInstanceOf[List[TimeSlot]].sorted.indexOf(timeSlot) / 2 + 1

                  Json.stringify(Json.obj(
                    "appointment" -> Json.obj(
                      "day" -> day,
                      "location" -> Json.obj(
                        "alternative" -> lecture.getAlternativeLectureRooms.map {
                          alr =>
                            Json.obj("alterLocation" -> Json.obj(
                              "building" -> alr.getHouse,
                              "room" -> alr.getNumber
                            ),
                              "alterDay" -> day,
                              "alterTitleShort" -> lecture.getShortName(course.getShortName),
                              "alterWeek" -> lecture.getDuration.getShortName,
                              "altereventType" -> eventType,
                              "hour" -> alternativeHour
                            )
                        },
                        "place" -> Json.obj(
                          "building" -> lecture.getLectureRoom.getHouse,
                          "room" -> lecture.getLectureRoom.getNumber
                        )
                      ),
                      "time" -> timeSlotToString(timeSlot),
                      "week" -> lecture.getDuration.getShortName
                    ),
                    "className" -> course.getShortName.toLowerCase,
                    "eventType" -> eventType,
                    "group" -> (if (group.isEmpty) {
                      group
                    } else {
                      " " + group
                    }),
                    "member" ->
                      lecture.getDocents.map {
                        d =>
                          val fhs_id = if (d.getUserId != null) {
                            d.getUserId
                          } else {
                            ""
                          }
                          Json.obj("fhs_id" -> fhs_id,
                            "name" -> d.getLastName
                          )
                      }
                    ,
                    "titleLong" -> lecture.getName.replaceAll("AE", "Ä").replaceAll("OE", "Ö").replaceAll("UE", "Ü"),
                    "titleShort" -> lecture.getShortName(course.getShortName)
                  )
                  )
                }
            }
            val content = List("[" + plan.mkString(",") + "]")

            Files.write(tmpFile, content, Charset.forName("UTF-8"), StandardOpenOption.WRITE)

            val sb = new StringBuilder

            /**
             * append command for install script
             */
            sb append "mongoimport --db spirit_news --collection schedulerecords --type json --file "

            sb append course.getShortName.toLowerCase
            sb append ".json --jsonArray "

            if (firstRun && !content.head.trim.equals("[]")) {
              firstRun = false
              sb append "--drop"
            }

            /** ignore this command if its an empty file */
            if (content.head.trim.equals("[]")) {
              sb append "NOIMPORT"
            }

            sb.toString()
        }.toList.filterNot(_.endsWith("NOIMPORT")).sortBy(-_.length)

        /** the longest command includs the --drop command */

        importCommands = "#!/bin/bash" :: "mongoexport --db spirit_news --collection entrycounters -o entrycounters.json" :: "mongoexport --db spirit_news --collection entrys -o entrys.json" :: importCommands

        importCommands = importCommands :+ "mongoimport --db spirit_news --collection entrycounters --type json --file entrycounters.json"

        importCommands = importCommands :+ "mongoimport --db spirit_news --collection entrys --type json --file entrys.json"

        importCommands = importCommands :+ "rm entr*.json"


        Files.write(importScriptFile, importCommands, Charset.forName("UTF-8"), StandardOpenOption.WRITE)

        Files.newDirectoryStream(path).foreach {
          p =>
            val zipPath = zipFs.getPath("/", p.getFileName.toString)
            Files.copy(p, zipPath)
            Files.delete(p)
        }
        zipFs.close()
        Files.delete(path)
        val responseFile = Paths.get(path.getParent.toString, ("/" + fileName + ".zip").replaceAll(" ", "")).toFile
        val fileContent = Enumerator.fromFile(responseFile)
        responseFile.deleteOnExit()

        //Ok.sendFile(content = fileContent, fileName = _ => semester.getName.replaceAll("/", "") + ".zip")
        Ok.stream(fileContent).withHeaders(CONTENT_TYPE -> "application/zip", CONTENT_LENGTH -> responseFile.length().toString, CONTENT_DISPOSITION -> ("attachment; filename=\"" + semester.getName.replaceAll("/", "") + ".zip" + "\""))
    }


  }

  def collectScheduleData(schedule: Schedule) = {

    val semester = schedule.getSemester

    val (allTimeslots, timerages) = timeRange

    val timeslots = schedule.getRoot.getChildren.flatMap {
      case wd: Weekday =>
        wd.getChildren.asInstanceOf[JavaList[TimeSlot]].toList
    }.toList

    val courseNames = timeslots.flatMap {
      ts =>
        ts.getLectures.flatMap {
          case lecture: Lecture =>
            lecture.getLectureParticipants.map {
              participant => participant.getCourseName
            }
        }
    }.toSet.toList.sorted

    val courses = Transactions.hibernateAction {
      implicit s =>
        s.createCriteria(classOf[Course]).add(Restrictions.in("shortName", courseNames)).setResultTransformer(CriteriaSpecification.DISTINCT_ROOT_ENTITY).setFetchMode("groups", FetchMode.JOIN).list().asInstanceOf[JavaList[Course]].toList.sortBy(_.getShortName)
    }

    val lectureShortCuts: Map[String, String] = timeslots.flatMap {
      ts =>
        ts.getLectures.flatMap {
          case lecture: Lecture =>
            lecture.getShortCuts.map {
              case (key, value) =>
                (value, lecture.getLectureSynonyms()(key))
            }
        }
    }.toMap

    (courseNames, timerages, timeslots, courses, lectureShortCuts)

  }

  def exportHTMLSchedule(id: Long) = Action {

    implicit request =>
      import scala.concurrent.ExecutionContext.Implicits.global

      val semester = findSemester(id)
      val schedule = findScheduleForSemester(semester)
      val fileName = "schedule" + semester.getName.replaceAll("/", "") + System.currentTimeMillis()
      val path = Files.createTempDirectory(fileName)

      val env = Map("create" -> "true")
      val zipUri = URI.create(("jar:file:" + path.getParent.toString + "/" + fileName + ".zip").replaceAll(" ", ""))
      val zipFs = FileSystems.newFileSystem(zipUri, env)

      val indexFile = Files.createFile(Paths.get(path.toString, "index.html"))
      val (courseNames, timerages, timeslots, courses, lectureShortCuts) = collectScheduleData(schedule)

      val content = List(views.html.localschedule.localschedule("", courseNames, timerages, timeslots, semester, courses, lectureShortCuts).toString().trim())

      Files.write(indexFile, content, Charset.forName("UTF-8"), StandardOpenOption.WRITE)

      val tmpAssetsPath = Paths.get(path.toString, "assets")
      val tmpBlockPath = Paths.get(path.toString, "block")

      Files.createDirectory(tmpAssetsPath)
      Files.createDirectory(tmpBlockPath)

      if (Play.isDev) {
        val assetsPath = current.getFile("/public").toPath
        Files.walkFileTree(assetsPath, new DirectoryCopyHelper(assetsPath, tmpAssetsPath))
      } else {
        val assetsUri = URI.create("jar:file:" + current.getFile("/lib/schedule-generator.schedule-generator-" + BuildInfo.version + "-assets.jar").toPath.toString + "!/public/")
        println(assetsUri)
        val assetsFileSystem = new ZipFileSystemProvider().newFileSystem(assetsUri, Map[String, String]())
        Files.walkFileTree(assetsFileSystem.getPath("/public/"), new ZIPFileExtractHelper(tmpAssetsPath, assetsFileSystem,assetsFileSystem.getPath("/")))
        Files.walkFileTree(tmpAssetsPath.resolve("public"), new DirectoryCopyHelper(tmpAssetsPath.resolve("public"),tmpAssetsPath) )
        Files.walkFileTree(tmpAssetsPath.resolve("public"), new DeleteDirectoryHelper())
        assetsFileSystem.close()
      }



      Files.walkFileTree(path, new ZIPFileDirectoryCopyHelper(path, zipFs))

      zipFs.close()
      Files.walkFileTree(path, new DeleteDirectoryHelper)
      val responseFile = Paths.get(path.getParent.toString, ("/" + fileName + ".zip").replaceAll(" ", "")).toFile
      val fileContent = Enumerator.fromFile(responseFile)
      responseFile.deleteOnExit()
      //Ok.sendFile(fileContent, fileName = _ => semester.getName.replaceAll("/", "") + ".zip")
      Ok.stream(fileContent).withHeaders(CONTENT_TYPE -> "application/zip", CONTENT_LENGTH -> responseFile.length().toString, CONTENT_DISPOSITION -> ("attachment; filename=\"" + semester.getName.replaceAll("/", "") + ".zip" + "\""))
  }

  /**
   * import an json file and parse it to database
   *
   */
  //FIXME: Still buggy
  def uploadFile = Action(parse.multipartFormData) {
    request =>
      request.body.file("fileUpload").map {
        file =>
          val mapper = new ObjectMapper

          import java.io.File
          val filename = file.filename
          val tmpFile = File.createTempFile(filename, "")

          tmpFile.deleteOnExit()
          file.ref.moveTo(tmpFile, replace = true)

          val jsonContainer = mapper.readValue(tmpFile, classOf[JsonContainer])

          Transactions.hibernateAction {
            implicit session =>
              val houseTemplates = jsonContainer.getHouses.flatMap(_.getRooms.flatMap(_.getCriteriaContainer.getCriterias.map {
                case tcrit: TimeSlotCriteria => tcrit.getWeekday
              }))

              (houseTemplates ++ jsonContainer.getWeekdayTemplates).map {
                wt =>
                  val dbresult = session.createCriteria(classOf[WeekdayTemplate]).add(Restrictions.eq("sortIndex", wt.getSortIndex)).uniqueResult()
                  if (dbresult == null) {
                    session.save(wt)
                  }
              }
          }

          Transactions.hibernateAction {
            implicit session =>
              jsonContainer.getHouses.foreach(_.getRooms.foreach(_.getRoomAttributes.foreach {
                attr =>
                  val dbResult = session.createCriteria(classOf[RoomAttributesEntity]).add(Restrictions.eq("attribute", attr.getAttribute)).uniqueResult()
                  if (dbResult == null) {
                    session.save(attr)
                  }
              }))

              jsonContainer.getHouses.foreach(session.save(_))
          }

          Transactions {
            implicit em =>

              // val semesters = jsonContainer.getSubjects.map(_.getSemester).toSet
              val courses = jsonContainer.getSubjects.flatMap(_.getCourses).toSet
              courses.foreach {
                course =>
                  val groups = course.getGroups.toSet
                  course.setGroups(groups.toList)
                  em.persist(course)
              }

            // semesters.foreach(em.persist(_))
          }

          Transactions {
            implicit em =>

              val docents = jsonContainer.getSubjects.flatMap(_.getDocents).toSet
              docents.foreach(em.persist(_))

              jsonContainer.getSubjects.foreach(em.persist(_))
          }


      }

      Redirect(routes.CExporter.page())
  }
}
